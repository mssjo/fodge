
#include "Diagram.hpp"
#include "DiagramNode.hpp"

#include <fstream>
#include <chrono>
#include <ctime>

#define BASE_RADIUS .4
#define RADIUS_INCR .05
#define BEND_RADIUS "4pt" 
#define VERT_OFFS .12

#define SINGLET_APPROACH_RATIO .6
#define INTSCT_MARGIN .5

#define GAP_BONUS PI
#define COLL_TOL PI/180
#define ROUND_SEP .3

#define LINE "thick"
#define SINGLET "thick,dashed"

/**
 * @brief Prints an informative header in a Ti<i>k</i>Z output file.
 * 
 * @param tikz a stream to the file.
 */
void print_TikZ_header(std::ostream& tikz){
    std::time_t gen_time = std::chrono::system_clock::to_time_t(
        std::chrono::system_clock::now());
    
    tikz << "% Generated by " FODGE_VERSION "\n"
            "% on " << std::ctime(&gen_time) << "% \n"
            "% This file can be used to draw flavour-ordered diagrams\n"
            "% using TikZ under LaTeX. A minimal implementation is\n"
            "% \n"
            "% \\documentclass{article}\n"
            "% \\usepackage{pgf, tikz}\n"
            "% \\usetikzlibrary{intersections}\n"
            "% \n"
            "% \\newcommand{\\ordidx}[1]{\\textbf{#1}} %or whatever formatting\n" 
            "%                                      %you want of vertex orders\n"
            "% \n"
            "% \\begin{document}\n"
            "% \t\\input{<this file>}\n"
            "% \\end{document}\n"
            "% \n";
}

/**
 * @brief Makes Ti<i>k</i>Z representations of a collection of diagrams.
 * 
 * @param filename  the basic filename to use; the actual files will be named 
 *                  <tt> <i>filename</i>_tikz.tex </tt>.
 * @param diagrs    the diagrams to represent. They are assumed to have the 
 *                  same number of legs.
 * @param split     if positive, the utput is split up into several files 
 *                  (labelled <tt> <i>filename</i>_tikz_1.tex </tt>, etc.) 
 *                  each containing @p split diagrams.
 * @param radius    if positive, this is the radius (in cm) used for the 
 *                  diagram drawings. Otherwise, a suitable radius is chosen 
 *                  based on the number of legs on then diagrams.
 * @param circle    if true, a thin grey circle is drawn around each diagram.
 * @return  @c 0 if everything went alright, 
 *          @c 1 (after printing a message to @c cerr) if it did not.
 * 
 * The files are created, opened and losed by this method. The diagrams
 * are printed as separate TikZpictures in the file, separated by
 * a small amount of space.
 */
int Diagram::TikZ(const std::string& filename, 
                  const std::vector<Diagram>& diagrs, 
                  int split, double radius, bool draw_circle)
{
    if(diagrs.empty())
        return 0;
    
    if(radius <= 0){
        radius = BASE_RADIUS + diagrs[0].n_legs * RADIUS_INCR;
        std::cout << "Radius automatically set to " << radius << " cm\n";
    }
    
    std::ofstream tikz;
    if(split > 0){
        for(int n = 0; n * split < diagrs.size(); n++){
            std::string splitfile = filename + "_" + std::to_string(n+1) 
                + ".tex";
            tikz.open(splitfile, std::ios::out | std::ios::trunc);
            if(tikz.fail()){
                std::cerr << "ERROR: could not open file \"" 
                    << splitfile << "\"\n";
                return 1;
            }
            print_TikZ_header(tikz);
            tikz << "%%% This file is part " << (n+1) 
                 << " of " << (1 + (diagrs.size() / split)) << ".\n\n";
            
            std::cout << "TikZing diagrams to file \"" 
                << splitfile << "\"...\n"; 
            
            for(int j = 0; j < split && j + n*split < diagrs.size(); j++)
                diagrs[j + n*split].TikZ(tikz, radius, j + n*split);
            
            tikz.close();
        }
    }
    else{
        tikz.open(filename + ".tex", std::ios::out | std::ios::trunc);
        if(tikz.fail()){
            std::cerr << "ERROR: could not open file \"" 
                << filename << ".tex\"\n";
            return 1;
        }
        print_TikZ_header(tikz);
        tikz << "\n";
        
        std::cout << "TikZing diagrams to file  \"" 
            << filename << ".tex\"...\n";  
        
        int idx = 0;
        for(const Diagram& d : diagrs)
            d.TikZ(tikz, radius, idx++, draw_circle);
        tikz.close();
    }
    
    return 0;
}

/**
 * @brief Makes a Ti<i>k</i>Z representation of a diagram.
 * 
 * @param tikz      a stream to the Ti<i>k</i>Z output.
 * @param radius    the radius (in cm) of the diagram.
 * @param index     the index of the diagram, 
 *                  used for reference in the Ti<i>k</i>Z file.
 * 
 * The diagram is drawn as a TikZpicture. The actual drawing is
 * delegated to its @link DiagramNode nodes @endlink.
 */
void Diagram::TikZ(std::ostream& tikz, 
                   double radius, int index, bool draw_circle) const{
    
    tikz << std::setprecision(3) << std::fixed << std::uppercase;
    
    if(index >= 0)
        tikz    << "%%% [" << index 
                << "] O(p^" << order << ") " 
                << n_legs << "-point diagram\n";
    
    tikz << "\\begin{tikzpicture}[>=stealth]\n";
    
    //Circle increases or decreases readability depending on who you ask
    if(draw_circle)
        tikz << "\t\\draw[black!30] (0,0) circle[radius=" << radius << "];\n";
    
    auto points = std::unordered_map<mmask, Point>();
    int idx = 0;
    while(!root.def_TikZ(Point::circle(radius, n_legs), &idx, points));
    
    root.adjust_TikZ(points, radius);
    
    balance_points(points);
    
    root.draw_TikZ(tikz, points);
    
    tikz << "\\end{tikzpicture}\\ \n%" << std::endl;
}


/**
 * @brief Recursively defines all points that are needed to draw a diagram.
 * 
 * @param perimeter a number of points equal to the number of legs on the 
 *                  diagram, evenly spaced around a circle. These serve as 
 *                  the location of the external legs, and act as references 
 *                  for the other points.
 * @param idx       a pointer to an index referring to the next point on the 
 *                  @p perimeter to be assigned. Should start at 0.
 * @param points    a list of the points belonging to all nodes in the diagram, 
 *                  indexed by the nodes' momentum masks, which are brief and 
 *                  unique.
 * @param parent_key the key (momentum mask) belonging to the parent of this 
 *                  node. Irrelevant for the root.
 * @return @c true if this node and all its descendants have successfully 
 *          assigned their nodes, @c false if another iteration is needed.
 * 
 * This method is pivotal to how the drawing turns out, since the other methods 
 * mostly connects the dots set up by it. It is designed around 3 main goals:
 * <ol>
 *  <li> The structure of the diagram should be easily readable.
 *  <li> The shape should not depend on which node is chosen as root.
 *  <li> The drawing should look good.
 * </ol>
 * 
 * The external legs are arranged evenly on a cycle to emphasise the 
 * flavour-ordering and to provide a easily generalised shape for the diagram 
 * that does not depend on which node is the root. All other nodes recieve a 
 * location that is the average of the locations of its neighbrouring nodes 
 * (parent and children). To avoid circular dependence, nodes that do not yet 
 * have a location are ignored. For aesthetic resons, the nodes are offset 
 * towards the center of the diagram by an amount corresponding to two 
 * neighbouring nodes located at the center.
 * 
 * There is a problem, though: the result of the above method depends on the 
 * order in which the locations are assigned, and thus on the choice of root. 
 * This leads to ugly, skewed diagrams. The solution is to make multiple 
 * iterations of the method until all nodes have been assigned locations. In 
 * each iteration, a node is assigned a location based only on those neighbours
 * that have already been assigned a location in a previous iteration; leaves 
 * are considered to always have assigned locations. If no such neighbour is 
 * available, the node is not assigned a location, the method returns @c false, 
 * and more iterations are needed. After a small number of iterations, this 
 * results in a diagram that is wholly unbiased and pretty damn gorgeous.
 */
bool DiagramNode::def_TikZ( 
        const std::vector<Point>& perimeter, int* idx,
        std::unordered_map<mmask, Point>& points, mmask parent_key) const
{
    
    if(is_leaf){
        Point pt = perimeter[(*idx)++];
        points.insert(std::make_pair(momenta, pt));
        
        return true;
    }
    
    Point pt = Point();
    int count = 0;
    //true if all descendants are done
    bool subtree_done = true;
    //true if node's own point is defined
    bool self_done = (points.find(momenta) != points.end());
    
    for(const FlavourTrace& tr : traces){
        for(const DiagramNode& leg : tr.legs){
           
            //if node is not done - find contributions from children
            if(!self_done){
                auto it = points.find(leg.momenta);
                
                if(leg.is_leaf){
                    if(it == points.end()){
                        leg.def_TikZ(perimeter, idx, points, momenta);
                        pt += points.at(leg.momenta);
                    }
                    else
                        pt += (*it).second;
                    
                    count++;
                }            
                else if(it != points.end()){
                    pt += (*it).second;
                    count++;
                }
            }
                
            //recurses regardless of done-ness -- there may be non-done nodes
            //further down
            if(!leg.is_leaf)
                subtree_done = leg.def_TikZ(perimeter, idx, points, momenta)
                        && subtree_done;
        }
    }  
    
    //adds contribution from parent
    if(!is_root){
        auto it = points.find(parent_key);
        if(it != points.end()){
            pt += (*it).second;
            count++;
        }
    }
    
    //if at least one neighbour is defined, define own point
    //(if not defined already)
    if(count > 0 && !self_done){
        //Adds an extra "phantom leg" to the normalisation to offset points
        //towards center
        pt *= 1./(n_legs + (is_root ? 1 : 2));
        points.insert(std::make_pair(momenta, pt));
        self_done = true;
    }
        
    return self_done && subtree_done;
}

/**
 * @brief Adjusts the points in a diagram drawing to avoid 
 * concave flavour traces.
 * 
 * @param points    lists the locations of all nodes, indexed by momentum mask.
 * @param radius    the radius of the drawing.
 * @param parent_key the key (momentum mask) of this node's parent. 
 *                  Irrelevant for the root.
 * 
 * A major problem when drawing some flavour-split diagrams is that the 
 * enveloping line around a flavour-split part of a vertex might become concave,
 * so that the other legs in that trace attach to the outside of its curve. This
 * looks ugly and can lead to errors when the lines become asymptotic to the 
 * curved line and fail to intersect it.
 * 
 * The solution is to rotate the locations of all nodes that are somehow 
 * attached to the curved line so that it becomes straight. These points 
 * include all descendants of the node in question through the offending flavour
 * trace, and if connected also all its ancestors. The only untouched nodes are 
 * those that are attached to the node via a different flavour trace.
 * 
 * The transformation becomes mathematically involved and isn't working exactly 
 * as intended, but the resuls look nice so I'll leave it for now. 
 * 
 * @todo fix this method if its error ever results in something bad.
 */
void DiagramNode::adjust_TikZ(
        std::unordered_map<mmask,Point>& points, 
        double radius, mmask parent_key) const
{
    if(is_leaf)
        return;
       
    Point pt = points.at(momenta);
    double ang_i, ang_f, ang_diff, ang_avg;
    
    if(traces.size() > 1){
        int idx = 0;
        for(const FlavourTrace& tr : traces){
            bool incl_parent = tr.connected;
            Point& i_pt = points.at(
                    incl_parent ? parent_key : tr.legs.front().momenta);
            
            ang_i = Point::angle(i_pt, pt);
            ang_f = Point::angle(points.at(tr.legs.back().momenta), pt);
            
            ang_diff = Point::normalise_angle(ang_f - ang_i);
            ang_avg  = Point::angle_in_range((ang_f + ang_i)/2, 
                                             ang_i, ang_f, PI);

            if(ang_diff > PI){
                
                //This implements the actual transformation.
                compress_points(points, pt, momenta, tr.momenta, incl_parent, 
                        ang_avg, ang_diff/PI);
            }
            
            idx++;
        }
    }
    
    for(const FlavourTrace& tr : traces){
        for(const DiagramNode& leg : tr.legs){
            leg.adjust_TikZ(points, radius, momenta);
        }
    }
}

/**
 * @brief Implements the transformation described in 
 *          @link DiagramNode::adjust_TikZ @endlink.
 * 
 * @param points    lists the locations of all nodes, indexed by momentum mask.
 * @param ref       the point around which other points are rotated.
 * @param key       the key (momentum mask) of this node.
 * @param sub_key   the key (momentum mask) of the flavour trace to be adjusted.
 * @param incl_parent if @c true, the parent is connected through the offending 
 *                  line and should be adjusted.
 * @param mid_angle the central angle, where the rotation is zero.
 * @param compression the factor by which all point's angular distance from 
 *                  @p mid_angle should be compressed.
 */
void DiagramNode::compress_points(
        std::unordered_map<mmask,Point>& points, const Point& ref,
        mmask key, mmask sub_key, bool incl_parent, 
        double mid_angle, double compression)
{
    
    for(auto& key_val : points){
        //Only adjusts children of the specific trace (i.e. points whose keys
        //are subsets of sub_key)
        //If incl_parent, also adjusts what would be children if the node's
        //parent were its child (i.e. points whose keys are not subsets of
        //this node's key)
        bool adjust =  SUBSET(key_val.first, sub_key) 
                    || (incl_parent && !SUBSET(key_val.first, key));
        //Also ignores the point itself
        if(!adjust || (key_val.first == key))
            continue;
        
        key_val.second = compress_point(ref, key_val.second,
                                        mid_angle, compression);
    }
}

/**
 * @brief Applies @link DiagramNode::compress_points @endlink to a single point.
 * 
 * @param ref       the point around which the point should be rotated.
 * @param pt        the point to rotate.
 * @param mid_angle the central angle. The goal is to change @p angle 
 *                  relative to this.
 * @param compression the angle relative to @p mid_angle should be compressed 
 *                  by this much.
 * @return the new location after the transformation.
 * 
 * The main crux is to rotate the point around @p ref while maintaining the same
 * distance to the origin, so that the diagram is not distorted. This takes a
 * bit of math.
 */
Point DiagramNode::compress_point(const Point& ref, const Point& pt,
        double mid_angle, double compression){
    
    //Original parameters of the point 
    //(note that angle and radius are defined from different origins)
    double angle = Point::angle(pt, ref);
    double radius = pt.magnitude();
    
    //Target parameters of the point (radius should be conserved)
    double diff = Point::angle_in_range(angle - mid_angle, -PI, PI);
    angle = mid_angle + (diff / compression);
    
    //Constructs unit vector (c,s) = (cos('angle'), sin('angle')), and 
    //then rescales it so that it reaches from ref = (x,y) to a distance 
    //r = 'radius' from origin
    // [ scale (c,s) + (x,y) ]^2 = r^2 
    // -> scale^2 + 2 scale [cx+sy] + [xx+yy] = r^2
    // -> scale = -[cx+sy] + sqrt([cx+sy]^2 + r^2 - [xx+yy])
    // (choosing positive solution)
    double cxsy = cos(angle) * ref.x() + sin(angle) * ref.y();
    double xxyy = ref.x()*ref.x() + ref.y()*ref.y();
    double scale = sqrt(cxsy*cxsy + radius*radius - xxyy) - cxsy;
    
    //Just in case something goes awry
    if(std::isnan(scale + angle)){
        std::cerr << "ERROR: internal error in TikZ adjustment.\n"
        "radius: " << radius << ", xxyy: " << xxyy << ", cxsy: " << cxsy 
            << std::endl;
        exit(EXIT_FAILURE);
    }
    
    return Point::polar(scale, angle, ref);
}

/**
 * @brief Rotates the diagram so that it becomes more "balanced".
 * 
 * @param pts the points of the diagram.
 * 
 * The balancing aims to minimise @f$\sum_i y_i^2@f$, the square vertical
 * deviation of all points from the centerline. Unless the diagram is
 * highly symmetric, this leads to two minimal configurations with a mostly
 * horizontal "backbone" similar to hand-drawn diagrams. Of these, the one with
 * lowest "centre of gravity" is chosen.
 * 
 * @todo choose weights that are less likely to be foiled by symmetric diagrams.
 */
void Diagram::balance_points(std::unordered_map<mmask, Point>& pts)
{
    if(pts.size() < 2)
        return;
    
    //Sums the x and y coordinates of the original points, as well as the
    //x^2, y^2 and x*y.
    double sx2 = 0, sy2 = 0, sxy = 0, sx = 0, sy = 0;
    for(auto& key_pt : pts){
        double x = key_pt.second.x();
        double y = key_pt.second.y();
        
        sx += x;
        sy += y;
        
        sx2 += x*x;
        sy2 += y*y;
        sxy += x*y;
    }
    
    //The derivative of sy2 *after* a rotation by 'a' is
    // sin(2a) [sx2 - sy2] + 2 cos(2a) sxy,
    //in terms of the sums *before* the rotation.
    //Half this angle therefore minimises the derivative.
    double dbl_ang = std::atan2(2*sxy, sy2 - sx2);
    
    //Ensures that the second derivative is positive -- we want a minimum!
    if(std::cos(dbl_ang) * (sx2 - sy2) - 2*std::sin(dbl_ang) * sxy < 0)
        dbl_ang += PI;
    
    //Angle of rotation
    double ang = dbl_ang/2;
    
    //Minimises the centre of gravity
    if(cos(ang) * sx + sin(ang) * sy > 0)
        ang += PI;
    
    //Rotates the points
    for(auto& key_pt : pts)
        key_pt.second.rotate(ang);
}


#define ENCOMP_NAME(m) "p" << std::hex << m << std::dec
#define INTSCT_NAME(m,n) "p" << std::hex << m << "x" << n << std::dec

/**
 * @brief Recursively draws a diagram using the points defined by
 * @link DiagramNode::def_TikZ @endlink.
 * 
 * @param tikz a stream to the Ti<i>k</i>Z output.
 * @param points    lists the locations of all nodes, indexed by momentum mask.
 * @param parent_key the key (momentum mask) of this node's parent. 
 *                  Irrelevant for the root.
 * @return The point to which a line should be drawn to connect with this node.
 * 
 * The main crux here is that lines may change between straight and curved,
 * and between singlet and normal, halfway between points. The solution is to
 * sometimes draw lines halfway. Children are allowed to be drawn before their
 * parents, and return a point that is either at the child or halfway between
 * it and the parent depending on what is appropriate. This way, each node only
 * has to worry about itself and what it should tell its parent.
 */
Point DiagramNode::draw_TikZ(
        std::ostream& tikz,
        const std::unordered_map<mmask, Point> points,
        mmask parent_key) const
{
    if(is_leaf)
        return points.at(momenta);
    
    vertex_order_TikZ(tikz, points, parent_key);
    
    Point this_pt = points.at(momenta);
    
    //Non-split vertex: print lines towards all children
    if(traces.size() == 1){        
        for(const DiagramNode& leg : traces[0].legs){
            Point target_pt = leg.draw_TikZ(tikz, points, momenta);
            tikz    << "\t\\draw[" 
                    << (leg.is_singlet ? SINGLET : LINE)
                    << "] " << this_pt << " -- " << target_pt
                    << ";\n";
        }
        
        return this_pt;
    }
    //Split vertex: iterate through all traces, and do the following:
    Point return_pt;
    for(FlavourTrace tr : traces){
        //First, define a line that will encompass the trace.
        
        //Beginning of line: parent if connected, otherwise first leg of trace
        Point begin = tr.connected ? points.at(parent_key) 
                : tr.legs.front().draw_TikZ(tikz, points, momenta);
        //End of line: last leg of trace
        Point end = tr.legs.back().draw_TikZ(tikz, points, momenta);
        
        //If beginning and end are collinear, there is no need to mess with
        //curved lines -- just draw all lines as if drawing a non-split vertex!
        //(Drawing line to parent is left to the parent.)
        if(false && Point::collinear(begin, this_pt, end, COLL_TOL)){ 
            for(int i = 0; i < tr.legs.size(); i++){
                Point target_pt;
                if(i == 0 && !tr.connected)
                    target_pt = begin;
                else if(i == tr.legs.size() - 1)
                    target_pt = end;
                else
                    target_pt = tr.legs[i].draw_TikZ(tikz, points, momenta);
                
                tikz    << "\t\\draw["
                        << (tr.legs[i].is_singlet ? SINGLET : LINE)
                        << "] " << this_pt << " -- " << target_pt
                        << ";\n";
            }

            if(tr.connected)
                return_pt = this_pt;
        }
        //Otherwise: draw an encompassing line from begin to end curving via
        //this point, and draw other lines intersecting it.
        else{
            //True if the entire encompassing line is a singlet
            bool fully_singlet = tr.legs.back().is_singlet 
                && ((tr.connected && is_singlet) 
                    || (!tr.connected && tr.legs.front().is_singlet));

            //Draws the curved segment. Names it using momenta as key in case
            //intersecting lines are needed.
            tikz    << "\t\\draw[name path=" << ENCOMP_NAME(tr.momenta)
                    << ", " << (fully_singlet ? SINGLET : LINE)
                    << "] "
                    << begin.to(this_pt, ROUND_SEP)
                    << " .. controls " << this_pt << " .. "
                    << end.to(this_pt, ROUND_SEP)
                    << ";\n";
                    
            //Draws other lines, using the intersections library
            for(int i = 0; i < tr.legs.size(); i++){
                Point source_pt;
                //Draws lines from begin or end specially: they attach to the
                //end of the curve, rather than intersecting it.
                //(Drawing line to parent is left to the parent.)
                if(i == tr.legs.size() - 1 || (i == 0 && !tr.connected)){
                    //Beware corner case when 0 == tr.legs.size() - 1 !!!
                    source_pt = (i == tr.legs.size() - 1) ? end : begin;
                    tikz    << "\t\\draw["
                            << (tr.legs[i].is_singlet ? SINGLET : LINE)
                            << "] "
                            << source_pt << " -- " 
                            << source_pt.to(this_pt, ROUND_SEP)
                            << ";\n";
                }
                else{
                    source_pt = tr.legs[i].draw_TikZ(tikz, points, momenta);
                    tikz    << "\t\\path[name path=" 
                            << INTSCT_NAME(tr.momenta, tr.legs[i].momenta)
                            << "] " << this_pt << " -- " << source_pt
                            << ";\n";
                    tikz    << "\t\\draw[name intersections={of="
                            << ENCOMP_NAME(tr.momenta)
                            << " and "
                            << INTSCT_NAME(tr.momenta, tr.legs[i].momenta)
                            << "}, "
                            << (tr.legs[i].is_singlet ? SINGLET : LINE)
                            << "] "
                            << source_pt << " -- (intersection-1)"
                            << ";\n";
                }
            }
            
            if(tr.connected)
                return_pt = begin.to(this_pt, ROUND_SEP);
        }
    }
    
    return return_pt;    
}

/**
 * @brief Draws a little number designating the order of a vertex.
 * 
 * @param tikz a stream to the Ti<i>k</i>Z output.
 * @param points    lists the locations of all nodes, indexed by momentum mask.
 * @param parent_key the key (momentum mask) of this node's parent. 
 *                  Irrelevant for the root.
 * 
 * The number is formatted by the LaTeX command <tt> ordidx </tt>, and is
 * not drawn on leading-order vertices.
 * 
 * This method could be very simple, but is not for aesthetic reasons. In order
 * not to collide with lines convening on the vertex, the number is drawn 
 * between the pair of lines with the largest angle between them. Preference is
 * given to drawing between lines separated by a flavour split. The distance 
 * between the number and the vertex is also adjusted to bring it as close as 
 * possible without colliding.
 * 
 * Next level would be to also adjust the placement so that no two numbers end 
 * up to close to each other. This would be pretty difficult, but would enhance
 * the looks of the diagrams.
 * @todo do this or conclude that it is silly. 
 */
void DiagramNode::vertex_order_TikZ(
        std::ostream& tikz,
        const std::unordered_map<mmask, Point> points,
        mmask parent_key) const
{
    if(is_leaf || order == 2)
        return;
    
    //Finds the polar angles between all neighbouring legs,
    //and marks whether they correspond to flavour split gaps.
    Point pt = points.at(momenta);
    std::vector<std::pair<double, bool>> angles_gaps = {};
    
    if(!is_root){
        angles_gaps.push_back(std::make_pair(
                Point::angle(points.at(parent_key), pt),
                false 
        ));
    }
    
    for(const FlavourTrace& tr : traces){
        for(const DiagramNode& leg : tr.legs){
            angles_gaps.push_back(std::make_pair(
                    Point::angle(points.at(leg.momenta), pt),
                    false
            ));
        }
        angles_gaps.back().second = (traces.size() > 1);
    }
    
        
    //Finds the widest gap, gives a bonus for being a flavour split.
    std::sort(angles_gaps.begin(), angles_gaps.end());
    double max_angle = Point::normalise_angle(
        angles_gaps.front().first - angles_gaps.back().first);
    if(angles_gaps.back().second)
        max_angle += GAP_BONUS;
    
    double angle;
    int max_idx = angles_gaps.size() - 1;
    for(int i = 0; i < angles_gaps.size() - 1; i++){
        angle = angles_gaps[i+1].first - angles_gaps[i].first;
        if(angles_gaps[i].second)
            angle += GAP_BONUS;
        
        if(angle > max_angle){
            max_angle = angle;
            max_idx = i;
        }
    }
    if(angles_gaps[max_idx].second)
        max_angle -= GAP_BONUS;
    
    //Calculates the exact location -- nearest distance at which a circle
    //of radius VERT_OFFS fits in the angle.
    double hmax = max_angle / 2;
    double offs = VERT_OFFS / sin(hmax);
    
    tikz    << "\t\\draw"
            << Point::polar(offs, angles_gaps[max_idx].first + hmax, pt)
            << " node [anchor=center] {\\ordidx " << order << "}"
            << ";\n";
    
    //Recursively cover the entire tree
    for(const FlavourTrace& tr : traces){
        for(const DiagramNode& leg : tr.legs){
            leg.vertex_order_TikZ(tikz, points, momenta);
        }
    }
    
}


