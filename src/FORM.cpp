
#include "Diagram.hpp"
#include "DiagramNode.hpp"
#include "Permutation.hpp"

#include <fstream>
#include <chrono>
#include <ctime>

#define INDENT_SIZE 4

void _print_FORM_header(std::ostream& form){
    std::time_t gen_time = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
    
    form << "*** Generated by " FODGE_VERSION "\n";
    form << "*** on " << std::ctime(&gen_time);
    form << "*** \n";
    form << "*** These .hf files can be used by FORM to evaluate a stripped amplitude.\n";
    form << "*** They can be automatically invoked by form.prc, or used manually.\n";
}

int Diagram::FORM(const std::string& filename, const std::vector<Diagram>& diagrs) 
{
    if(diagrs.empty())
        return 0;
    
    std::ofstream form;
    
    form.open(filename + "_diagr.hf", std::ios::out | std::ios::trunc);
    if(form.fail()){
        std::cerr << "ERROR: failed to open file \"" << filename << "_diagr.hf\"\n";
        return 1;
    }
    _print_FORM_header(form);
    form << "*** This file defines the diagrams, and is the second file to be used:\n";
    form << "*** after " << filename << "_vert.hf, but before " << filename << "_ampl.hf.\n\n";
    
    std::cout << "FORMing diagrams to file  \"" << filename << "_diagr.hf\"...\n";
    
    std::map<vertex, int> verts = {};
    std::vector<int> prev_flav_split = {};
    int diagr_idx = 0;
    for(const Diagram& d : diagrs){
        if(d.flav_split != prev_flav_split){
            prev_flav_split = d.flav_split;
            diagr_idx = 0;
        }
        
        d.FORM(form, verts, ++diagr_idx);
    }
    
    form.close();
    
    form.open(filename + "_ampl.hf", std::ios::out | std::ios::trunc);
    if(form.fail()){
        std::cerr << "ERROR: failed to open file \"" << filename << "_ampl.hf\"\n";
        return 1;
    }
    _print_FORM_header(form);
    form << "*** This file sums up the amplitude, and is the last file to be used:\n";
    form << "*** after " << filename << "_vert.hf and " << filename << "_diagr.hf.\n\n";
    
    std::cout << "FORMing amplitude to file \"" << filename << "_ampl.hf\"...\n";
    
    form << "[M" << diagrs[0].n_legs << "p" << diagrs[0].order << "] =";
    prev_flav_split = {};
    for(int i = 0; i < diagrs.size(); i++){
        if(i % 5 == 0)
            form << "\n" << std::string(INDENT_SIZE, ' ');
        
        if(diagrs[i].flav_split != prev_flav_split){
            prev_flav_split = diagrs[i].flav_split;
            diagr_idx = 0;
        }
            
        form << (i > 0 ? " + " : "   ");
        diagrs[i].diagram_name_FORM(form, ++diagr_idx);
    }
    form << ";";
    
    form.close();
    
    form.open(filename + "_vert.hf", std::ios::out | std::ios::trunc);
    if(form.fail()){
        std::cerr << "ERROR: failed to open file \"" << filename << "_vert.hf\"\n";
        return 1;
    }
    _print_FORM_header(form);
    form << "*** This file defines the vertices, and is the first file to be used:\n";
    form << "*** before " << filename << "_diagr.hf and " << filename << "_ampl.hf.\n\n";
    
    std::cout << "FORMing vertices to file  \"" << filename << "_vert.hf\"...\n";
    
    DiagramNode::vertices_FORM(form, verts);
    form.close();
    
    return 0;
}


void Diagram::FORM(std::ostream& form, std::map<vertex,int>& verts, int index) 
const {
    auto local_verts = std::map<vertex, int>();
    
    diagram_name_FORM(form, index);
    form << " =\n";
    root.FORM(form, local_verts, 1, Propagator(0, n_legs, 0, 0));
    
    for(auto vert_count : local_verts){
        if(DiagramNode::heavy_vertex(vert_count.first)){
            for(int i = 0; i < vert_count.second; i++){
                form << std::string(2*INDENT_SIZE, ' ') << " * "; 
                DiagramNode::vertex_name_FORM(form, vert_count.first, i+1, false);
                form << "\n";
            }
        }
            
        auto global_count = verts.find(vert_count.first);
        if(global_count == verts.end())
            verts.insert(vert_count);
        else
            (*global_count).second += vert_count.second;
    }
    
    if(labellings.size() > 1){
        form << " * ( ";
        labellings.front().FORM(form);
        for(int i = 1; i < labellings.size(); i++){
            form << "\n   + ";
            labellings[i].FORM(form);
        }
        form << "\n)";
    }
    
    form << ";\n\n";
}

void DiagramNode::FORM(
        std::ostream& form, std::map<vertex, int>& verts, 
        int depth, const Propagator& prop) 
const {
    
    if(is_leaf){
        form << 1 + bitwise::unshift(momenta);
        return;
    }
    
    std::vector<int> flav_split = {};
    for(const auto tr : traces)
        flav_split.push_back(tr.legs.size() + (tr.connected ? 1 : 0));
    
    auto sort_perm = permute::Permutation::sorting_permutation(
        flav_split.begin(), flav_split.end());
    sort_perm.permute(flav_split.begin());
    
    assert(std::is_sorted(flav_split.begin(), flav_split.end()));    
    
    vertex vert = std::make_pair(order, flav_split);
    auto vert_count = verts.find(vert);
    int vert_idx;
    if(vert_count == verts.end()){
        verts.insert(std::make_pair(vert, 1));
        vert_idx = 1;
    }
    else
        vert_idx = ++((*vert_count).second);
    
    form << std::string(depth*INDENT_SIZE, ' ') << "diagram(";
    vertex_name_FORM(form, vert, vert_idx, heavy_vertex(vert));
    
    for(int i = 0; i < traces.size(); i++){
        auto tr = traces[ sort_perm[i] ];
        
        for(const auto leg : tr.legs){
            form << (leg.is_leaf ? ", " : ",\n");
            leg.FORM(form, verts, depth+1, prop);
            
            if(!leg.is_leaf)
                form << std::string((depth+1)*INDENT_SIZE, ' ');
        }
        if(tr.connected){
            form << (is_singlet ? ", singlet(" : ", prop(");
            prop.FORM(form, momenta);
        }
    }
    form << ")\n";
}

void Labelling::FORM(std::ostream& form) const{
    
    if(perm.is_identity()){
        form << "1";
        return;
    }
    
    auto it = perm.begin();
    form << "permute(" << (1 + *it);
    for(++it; it != perm.end(); ++it)
        form << ", " << (1 + *it);
        
    form << ")";
}

void DiagramNode::vertices_FORM(std::ostream& form, std::map<vertex, int>& verts){
    for(auto& vert_count : verts){
        bool heavy = heavy_vertex(vert_count.first);
        int n_legs = 0;
        for(int r : vert_count.first.second)
            n_legs += r;
        
        form << "#redefine SPLIT \"split(" << vert_count.first.second[0];
        for(int i = 1; i < vert_count.first.second.size(); i++)
            form << "," << vert_count.first.second[i];
        form << ")\"\n";
        
        for(int i = 1; i <= vert_count.second; i++){
            if(heavy){
                form << "#define ";
                vertex_name_FORM(form, vert_count.first, i, true);
                form << " \"vertid(`VERTID')\"\n";
            }
            
            form << "#call sfrule(" << n_legs << "," 
                 << vert_count.first.first << ",";
            vertex_name_FORM(form, vert_count.first, i, false);
            form << ")\n";
        }
        
        form << "\n";
    }
}
    

bool DiagramNode::heavy_vertex(const vertex& vert){
    int n_legs = 0;
    for(int r : vert.second)
        n_legs += r;
    
    return vert.first > 4 && n_legs > 4;
}
    

void DiagramNode::vertex_name_FORM(std::ostream& form, const vertex& vert, int index, bool vertid){
    form << (vertid ? "`[vid" : "[V") << vert.second[0];
    for(int i = 1; i < vert.second.size(); i++)
        form << "/" << vert.second[i];
    form << "p" << vert.first << "." << index << (vertid ? "]'" : "]");
}

void Diagram::diagram_name_FORM(std::ostream& form, int index) const {
    form << "[D" << flav_split[0];
    for(int i = 1; i < flav_split.size(); i++)
        form << "/" << flav_split[i];
    form << "." << index << (singlet_diagram ? "(s)]" : "]");
    
}
    

void Propagator::FORM(std::ostream& form, mmask prop) const {    
    mmask one = (mmask) 1;
    prop = normalise_mmask(prop, one << (n_mom - 1), (one << n_mom) - 1);
    
    bool first = true;
    for(int i = 0; (one << i) < prop && i < n_mom; i++){
        if(prop & (one << i)){
            if(!first)
                form << "+";
            else
                first = false;
            
            form << "p" << (i+1);
        }
    }
}
