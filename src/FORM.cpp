
#include "Diagram.hpp"
#include "DiagramNode.hpp"
#include "Permutation.hpp"

#include <fstream>
#include <chrono>
#include <ctime>

#define INDENT_SIZE 4

/**
 * @brief Prints an informative header in a FORM output file.
 * 
 * @param form a stream to the file.
 */
void _print_FORM_header(std::ostream& form){
    std::time_t gen_time = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
    
    form << "*** Generated by " FODGE_VERSION "\n"
            "*** on " << std::ctime(&gen_time) <<
            "*** \n"
            "*** These .hf files can be used by FORM to evaluate a stripped amplitude.\n"
            "*** They can be automatically invoked by form.prc, or used manually.\n";
}

/**
 * @brief Outputs a collection of diagrams for amplitude calculation by FORM.
 * 
 * @param filename  the basic filename. The files will be named 
 *                  <tt> <i>filename</i>_<i>part</i>.hf </tt>, where @c part is 
 *                  @c vert, @c diagr or @c ampl. 
 * @param diagrs    the diagrams.
 * @return  @c 0 if everything went alright, 
 *          @c 1 (after printing a message to @c cerr) if it did not.
 * 
 * The output is in separate files since the information needed to produce
 * diagr.hf is available before that needed for vert.hf, despite the latter
 * being needed by FORM first.
 * 
 * This method mostly manages the files. The actual code generation is delegated
 * to the @link DiagramNode nodes @endlink.
 */
int Diagram::FORM(const std::string& filename, 
                  const std::vector<Diagram>& diagrs) 
{
    if(diagrs.empty())
        return 0;
    
    std::ofstream form;
    
    //Produces diagrams
    form.open(filename + "_diagr.hf", std::ios::out | std::ios::trunc);
    if(form.fail()){
        std::cerr << "ERROR: failed to open file \"" << filename << "_diagr.hf\"\n";
        return 1;
    }
    _print_FORM_header(form);
    form << "*** This file defines the diagrams, and is the second file to be used:\n";
    form << "*** after " << filename << "_vert.hf, but before " << filename << "_ampl.hf.\n\n";
    
    std::cout << "FORMing diagrams to file  \"" << filename << "_diagr.hf\"...\n";
    
    std::map<vertex, int> verts = {};
    std::vector<int> prev_flav_split = {};
    int diagr_idx = 0;
    for(const Diagram& d : diagrs){
        //Runs a separate index for each flavour structure, for clarity.
        if(d.flav_split != prev_flav_split){
            prev_flav_split = d.flav_split;
            diagr_idx = 0;
        }
        
        d.FORM(form, verts, ++diagr_idx);
    }
    
    form.close();
    
    //Produces amplitude
    form.open(filename + "_ampl.hf", std::ios::out | std::ios::trunc);
    if(form.fail()){
        std::cerr << "ERROR: failed to open file \"" << filename << "_ampl.hf\"\n";
        return 1;
    }
    _print_FORM_header(form);
    form << "*** This file sums up the amplitude, and is the last file to be used:\n";
    form << "*** after " << filename << "_vert.hf and " << filename << "_diagr.hf.\n\n";
    
    std::cout << "FORMing amplitude to file \"" << filename << "_ampl.hf\"...\n";
    
    form << "global [M" << diagrs[0].n_legs << "p" << diagrs[0].order << "] =";
    prev_flav_split = {};
    for(int i = 0; i < diagrs.size(); i++){
        if(i % 5 == 0)
            form << "\n" << std::string(INDENT_SIZE, ' ');
        
        //Same separate-index deal here as above.
        if(diagrs[i].flav_split != prev_flav_split){
            prev_flav_split = diagrs[i].flav_split;
            diagr_idx = 0;
        }
            
        form << (i > 0 ? " + " : "   ");
        diagrs[i].diagram_name_FORM(form, ++diagr_idx);
    }
    form << ";";
    
    form.close();
    
    //Produces vertices
    form.open(filename + "_vert.hf", std::ios::out | std::ios::trunc);
    if(form.fail()){
        std::cerr << "ERROR: failed to open file \"" << filename << "_vert.hf\"\n";
        return 1;
    }
    _print_FORM_header(form);
    form << "*** This file defines the vertices, and is the first file to be used:\n";
    form << "*** before " << filename << "_diagr.hf and " << filename << "_ampl.hf.\n\n";
    
    std::cout << "FORMing vertices to file  \"" << filename << "_vert.hf\"...\n";
    
    DiagramNode::vertices_FORM(form, verts);
    form.close();
    
    return 0;
}


/**
 * @brief Generates FORM code from a diagram.
 * 
 * @param form a stream to the FORM output.
 * @param verts a map keeping a tally of all vertices needed. All vertices in a diagram must be distinct, but the same vertex can be reused by multiple diagrams. Vertices can be very expensive to compute, so a minimal amount of vertices is necessary.
 * @param index the index of the diagram, for reference in the files.
 */
void Diagram::FORM(std::ostream& form, std::map<vertex,int>& verts, int index) 
const {
    std::map<vertex, int> local_verts = {};
    
    //Outputs the code
    form << "global ";
    diagram_name_FORM(form, index);
    form << " =\n";
    root.FORM(form, local_verts, 1, Propagator(0, n_legs, 0, 0));
    
    //Adds the vertices needed for this diagram to the total count.
    for(auto local_count : local_verts){
        //Also appends heavy vertices outside the main "diagram(...)"
        //References to its index inside will handle the correct placement.
        if(DiagramNode::heavy_vertex(local_count.first)){
            for(int i = 0; i < local_count.second; i++){
                form << std::string(2*INDENT_SIZE, ' ') << " * "; 
                DiagramNode::vertex_name_FORM(form, local_count.first, i+1, false);
                form << "\n";
            }
        }
        
        //This ensures that each entry in verts is the maximum of all
        //corresponding entries in local_verts across all diagrams.
        auto global_count = verts.find(local_count.first);
        if(global_count == verts.end())
            verts.insert(local_count);
        else
            global_count->second = std::max(local_count.second, global_count->second);
    }
    
    //Adds permutations corresponding to the distinct labellings.
    if(labellings.size() > 1){
        form << " * ( ";
        labellings.front().FORM(form);
        for(int i = 1; i < labellings.size(); i++){
            form << "\n   + ";
            labellings[i].FORM(form);
        }
        form << "\n)";
    }
    
    form << ";\n\n";
}

/**
 * @brief Recursively generates a FORM description of a diagram.
 * 
 * @param form  a stream to the FORM output.
 * @param verts a map to keep tally of all vertices needed by this diagram.
 * @param depth the depth in the diagram, used for indentation of the output.
 * @param prop  a dummy propagator used to format the propagators. It can be any 
 *              propagator taken from the diagram, or just a dud with the 
 *              correct number of legs.
 * 
 * Diagrams are specified in FORM using the procedure "diagram.prc", which
 * is structured pretty much like the tree in FODGE, except that the division
 * into flavour traces is implicit by the flavour split and the order of the
 * indices.
 * 
 * "diagram.prc" was designed for easy human-readable/writable input, but it
 * forces FORM to do quite a bit of bookkeeping. Since FODGE is much less time-
 * consuming than runing FORM on its output, it might be worthwhile to produce
 * more low-level output and let FORM focus on the algebra.
 * @todo maybe do this.
 */
void DiagramNode::FORM(
        std::ostream& form, std::map<vertex, int>& verts, 
        int depth, const Propagator& prop) 
const {
    
    //External leg: just output the index
    if(is_leaf){
        form << 1 + bitwise::unshift(momenta);
        return;
    }
    
    //Determines the flavour split of the vertex
    std::vector<int> flav_split = {};
    for(const auto tr : traces)
        flav_split.push_back(tr.legs.size() + (tr.connected ? 1 : 0));
    
    //This makes sure that the flavour split is sorted (i.e. canonical)
    //and that we know how to get there fore reference below.
    auto sort_perm = permute::Permutation::sorting_permutation(
        flav_split.begin(), flav_split.end());
    sort_perm.permute(flav_split.begin());
    
    //Counts the vertex
    vertex vert = std::make_pair(order, flav_split);
    auto vert_count = verts.find(vert);
    int vert_idx;
    if(vert_count == verts.end()){
        verts.insert(std::make_pair(vert, 1));
        vert_idx = 1;
    }
    else
        vert_idx = ++((*vert_count).second);
    
    //Adds a new level of nesting for diagram.prc
    form << std::string(depth*INDENT_SIZE, ' ') << "diagram(";
    if(heavy_vertex(vert)){
        form << "`";
        vertex_name_FORM(form, vert, vert_idx, true);
        form << "'";
    }
    else
        vertex_name_FORM(form, vert, vert_idx, false);
    
    for(int i = 0; i < traces.size(); i++){
        auto tr = traces[ sort_perm[i] ];
        
        //Recurses and does some indentation/line breaking to keep
        //things readable.
        for(const auto leg : tr.legs){
            form << (leg.is_leaf ? ", " : ",\n");
            leg.FORM(form, verts, depth+1, prop);
            
            if(!leg.is_leaf)
                form << std::string((depth+1)*INDENT_SIZE, ' ');
        }
        if(tr.connected){
            //Writes out the propagator back to the parent
            form << (is_singlet ? ", singlet(" : ", prop(");
            prop.FORM(form, momenta);
            form << ")";
        }
    }
    form << ")\n";
}

/**
 * @brief Prints a labelling as the flavour index permutation 
 *      needed to put it on the diagram.
 * 
 * @param form a stream to the FORM output.
 */
void Labelling::FORM(std::ostream& form) const{
    
    if(perm.is_identity()){
        form << "1";
        return;
    }
    
    auto it = perm.begin();
    form << "permute(" << (1 + *it);
    for(++it; it != perm.end(); ++it)
        form << ", " << (1 + *it);
        
    form << ")";
}

/**
 * @brief Prints a list of vertices to be generated by FORM.
 * 
 * @param form  a stream to the FORM output.
 * @param verts the vertices, mapping to the number required of each.
 * 
 * A vertex is produced by the procedure "sfrule.prc" (Stripped Feynman RULE),
 * which generates a vertex factor given its number of legs and order, and
 * provided that the macro "SPLIT" is set to the correct flavour split.
 */
void DiagramNode::vertices_FORM(std::ostream& form, std::map<vertex, int>& verts){
    for(auto& vert_count : verts){
        bool heavy = heavy_vertex(vert_count.first);
        int n_legs = 0;
        for(int r : vert_count.first.second)
            n_legs += r;
        
        //We could do with much fewer #redefine's if we sorted the map 
        //differently, but that would be a small hassle for very little gain.
        form << "#redefine SPLIT \"split(" << vert_count.first.second[0];
        for(int i = 1; i < vert_count.first.second.size(); i++)
            form << "," << vert_count.first.second[i];
        form << ")\"\n";
        
        //Defines as many vertices as needed, and makes macros for their
        //indices if they are heavy.
        for(int i = 1; i <= vert_count.second; i++){
            if(heavy){
                form << "#define ";
                vertex_name_FORM(form, vert_count.first, i, true);
                form << " \"vertid(`VERTID')\"\n";
            }
            
            form << "#call sfrule(" << n_legs << "," 
                 << vert_count.first.first << ",";
            vertex_name_FORM(form, vert_count.first, i, false);
            form << ")\n";
        }
        
        form << "\n";
    }
}
    

/**
 * @brief Determines if a vertex is "heavy".
 * 
 * @param vert the vertex
 * @return bool @c true if it is heavy, @c false otherwise.
 * 
 * Some vertices with long expressions can't fit inside function arguments
 * as needed by "diagram.prc". Such vertices we call "heavy". Workarounds are
 * needed for that, and this method finds out where they are necessary.
 * 
 * The rule of thumb is that no LO or NLO vertex is heavy, and that no 4-point
 * vertex is heavy, but that other vertices are likely to be heavy. If it fails
 * in the future, change the definitions here.
 */
bool DiagramNode::heavy_vertex(const vertex& vert){
    int n_legs = 0;
    for(int r : vert.second)
        n_legs += r;
    
    return vert.first > 4 && n_legs > 4;
}
    

/**
 * @brief Outputs the name of a vertex to FORM.
 * 
 * @param form  a stream to the FORM output.
 * @param vert  the vertex.
 * @param index the index of the vertex for generation of multiple identical 
 *              vertices.
 * @param vertid if @c false, this is the name of a vertex. 
 *              If @c true, this is the name of a placeholder macro for the 
 *              vertex ID of a 
 *              @link DiagramNode::heavy_vertex heavy vertex @endlink.
 * 
 * The name is in the format 
 * <tt> [V<i>flav_split</i>p<i>order</i>.<i>index</i>] </tt>, 
 * where @c flav_split is written as numbers separated by slashes. This is a 
 * remnant of a notation I used before I had fully developed the notion of a 
 * flavour split, but the notation has stuck in my FORM files so it would be 
 * inconsistent to change it.
 * 
 * When @p vertid is true, the square brackets are removed and all 
 * non-alphanumeric characters are replaced with letters to conform with FORM's
 * rules for the names of preprocessor variables.
 */
void DiagramNode::vertex_name_FORM(std::ostream& form, const vertex& vert, 
                                int index, bool vertid)
{
    form << (vertid ? "V" : "[V") << vert.second[0];
    for(int i = 1; i < vert.second.size(); i++)
        form << (vertid ? "s" : "/") << vert.second[i];
    form << "p" << vert.first << (vertid ? "v" : ".") 
         << index << (vertid ? "" : "]");
}

/**
 * @brief Outputs the name of a diagram to FORM.
 * 
 * @param form a stream to the FORM output.
 * @param index the index of the diagram.
 * 
 * The name is in the format <tt> [D<i>flav_split</i>p<i>order</i>.<i>index</i>] </tt>, 
 * where @c flav_split is written as numbers separated by slashes. This is a 
 * remnant of a notation I used before I had fully developed the notion of a 
 * flavour split, but the notation has stuck in my FORM files so it would be 
 * inconsistent to change it.
 */
void Diagram::diagram_name_FORM(std::ostream& form, int index) const {
    form << "[D" << flav_split[0];
    for(int i = 1; i < flav_split.size(); i++)
        form << "/" << flav_split[i];
    form << "." << index << (singlet_diagram ? "(s)]" : "]");
    
}
    

/**
 * @brief Writes a propagator or singlet propagator to FORM.
 * 
 * @param form  a stream to the FORM output.
 * @param prop  the propagator momentum mask. @p this is only used as a dummy
 *              for formatting.
 * 
 * The propagator is written as <tt> prop(p<i>i1</i> + p<i>i2</i> + ...) </tt>,
 * where the @c i are the indices of the momenta (counting from 1). For singlets,
 * @c prop is replaced by @c singlet.
 */
void Propagator::FORM(std::ostream& form, mmask prop) const {    
    mmask one = (mmask) 1;
    mmask nprop = normalise_mmask(prop, one << (n_mom - 1), (one << n_mom) - 1);
    
    if(prop != nprop)
        form << "-(";
    bool first = true;
    for(int i = 0; (one << i) < nprop && i < n_mom; i++){
        if(nprop & (one << i)){
            if(!first)
                form << "+";
            else
                first = false;
            
            form << "p" << (i+1);
        }
    }
    if(prop != nprop)
        form << ") ";
}
